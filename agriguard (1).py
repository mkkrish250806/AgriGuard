# -*- coding: utf-8 -*-
"""AgriGuard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mEKyjAK52QrtrrAI42zOwebwjYeIr4JE
"""

# Install all required packages
!pip install torch torchvision
!pip install fastapi uvicorn pyngrok nest-asyncio
!pip install python-multipart # For file uploads in FastAPI
!pip install aiohttp # For async requests
!pip install kaleido cohere openai # Common dependencies that can be useful

# Import necessary libraries for file handling
import os
from google.colab import files

# Prompt to upload your kaggle.json file
print("Please upload your kaggle.json file")
uploaded = files.upload()

# Move the kaggle.json file to the required directory and set permissions
if 'kaggle.json' in uploaded:
    !mkdir -p ~/.kaggle
    !mv kaggle.json ~/.kaggle/
    !chmod 600 ~/.kaggle/kaggle.json
    print("Kaggle API configured successfully!")

    # Download the dataset from Kaggle
    # This is a large dataset, so it might take a few minutes
    !kaggle datasets download -d vipoooool/new-plant-diseases-dataset

    # Unzip the dataset quietly
    print("Unzipping dataset... This will take a moment.")
    !unzip -q new-plant-diseases-dataset.zip

    print("Dataset is ready!")
else:
    print("kaggle.json not found. Please upload it.")

def suggest_actions(self, label, prob):
    medicines = {
        "mildew": ("Fungicide Spray", 350),
        "rust": ("Copper-based Fungicide", 420),
        "blight": ("Mancozeb Solution", 300),
        "healthy": ("No medicine needed", 0)
    }

    if "healthy" in label.lower():
        return {"suggestion": "✅ No action needed.",
                "medicine": "None", "price": 0}
    elif prob < 0.6:
        return {"suggestion": "⚠ Low confidence. Capture clearer image.",
                "medicine": "Consult expert", "price": 0}
    else:
        for key, (med, price) in medicines.items():
            if key in label.lower():
                return {"suggestion": "Apply treatment immediately.",
                        "medicine": med, "price": price}
        return {"suggestion": "👨‍🌾 Consult agronomist.",
                "medicine": "Not available", "price": 0}

import torch
from torchvision import datasets, transforms, models
from torch.utils.data import DataLoader

# Define the paths to your data
data_dir = '/content/New Plant Diseases Dataset(Augmented)/New Plant Diseases Dataset(Augmented)'
train_dir = os.path.join(data_dir, 'train')
valid_dir = os.path.join(data_dir, 'valid')

# Define transformations for the training and validation sets
# We apply augmentation to the training set to make the model more robust
train_transforms = transforms.Compose([
    transforms.RandomResizedCrop(224),
    transforms.RandomHorizontalFlip(),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])

valid_transforms = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])

# Load the datasets with ImageFolder
train_data = datasets.ImageFolder(train_dir, transform=train_transforms)
valid_data = datasets.ImageFolder(valid_dir, transform=valid_transforms)

# Define the dataloaders
batch_size = 64 # You can reduce this if you face memory issues
train_loader = DataLoader(train_data, batch_size=batch_size, shuffle=True)
valid_loader = DataLoader(valid_data, batch_size=batch_size)

# Get the class names
class_names = train_data.classes
num_classes = len(class_names)
print(f"Found {num_classes} classes.")
# print(class_names) # Uncomment to see all disease classes

import torch.nn as nn
import torch.optim as optim

# Check if a GPU is available and set the device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Using device: {device}")

# Load a pre-trained ResNet-18 model
model = models.resnet18(pretrained=True)

# Freeze all the parameters in the pre-trained model
for param in model.parameters():
    param.requires_grad = False

# Replace the final layer (the classifier) with a new one for our specific number of classes
num_ftrs = model.fc.in_features
model.fc = nn.Linear(num_ftrs, num_classes)

# Move the model to the GPU
model = model.to(device)

# Define the loss function and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.fc.parameters(), lr=0.001, momentum=0.9) # Only train the new layer

# --- Training Loop ---
epochs = 5 # For a hackathon, 5 epochs is enough to get a good result
print("Starting model training...")

for epoch in range(epochs):
    model.train()
    running_loss = 0.0
    for inputs, labels in train_loader:
        inputs, labels = inputs.to(device), labels.to(device)

        optimizer.zero_grad()

        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        running_loss += loss.item() * inputs.size(0)

    epoch_loss = running_loss / len(train_loader.dataset)
    print(f"Epoch {epoch+1}/{epochs}.. Training Loss: {epoch_loss:.4f}")

print("\nFinished Training!")

# Save the trained model
torch.save(model.state_dict(), 'agri_guard_model.pth')
print("Model saved as agri_guard_model.pth")

from fastapi import FastAPI, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse # <-- Important: We need this import
import uvicorn
import asyncio
import nest_asyncio
from PIL import Image
import io
import json

# Create the FastAPI app
app = FastAPI(title="AgriGuard AI API")

# Allow all origins for CORS (Cross-Origin Resource Sharing)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Load the trained model
model_path = 'agri_guard_model.pth'
model.load_state_dict(torch.load(model_path, map_location=device))
model.eval() # Set model to evaluation mode

# Define the image transformation for prediction
predict_transform = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])

def predict_image(image_bytes):
    """Function to predict the class of an image"""
    image = Image.open(io.BytesIO(image_bytes)).convert('RGB')
    input_tensor = predict_transform(image).unsqueeze(0)
    input_tensor = input_tensor.to(device)

    with torch.no_grad():
        output = model(input_tensor)
        _, pred_idx = torch.max(output, 1)

    # Clean up the class name for better readability
    prediction = class_names[pred_idx.item()].replace('___', ' ').replace('_', ' ')
    return prediction

# --- CORRECTED PART ---
# Define the root endpoint to serve our HTML page instead of the JSON message
@app.get("/", response_class=FileResponse)
async def read_index():
    return 'index.html'
# --------------------

# Define the prediction endpoint
@app.post("/predict")
async def predict(file: UploadFile = File(...)):
    image_bytes = await file.read()
    prediction = predict_image(image_bytes)
    return {"disease": prediction}

print("✅ FastAPI app created and configured to serve the web interface.")

# Create the HTML for our frontend
html_content = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🌱 AgriGuard - Crop Disease Detection</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f0fdf4; color: #14532d; margin: 0; padding: 2rem; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        .container { max-width: 600px; width: 100%; background: #ffffff; border-radius: 16px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); padding: 2.5rem; text-align: center; border: 1px solid #bbf7d0; }
        .header { margin-bottom: 2rem; }
        .header h1 { font-size: 2.5rem; color: #166534; margin: 0; }
        .header h1 span { color: #84cc16; }
        .header p { color: #4b5563; font-size: 1.1rem; }
        .upload-area { border: 3px dashed #84cc16; border-radius: 12px; padding: 2rem; margin-bottom: 1.5rem; cursor: pointer; transition: background-color 0.3s; }
        .upload-area:hover { background-color: #f7fee7; }
        .upload-area p { margin: 0; font-size: 1.2rem; color: #3f6212; }
        #file-input { display: none; }
        #image-preview { margin-top: 1.5rem; max-width: 100%; max-height: 300px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        #result { margin-top: 1.5rem; padding: 1.5rem; background: #ecfccb; border: 1px solid #84cc16; border-radius: 12px; display: none; }
        #result h2 { margin: 0 0 0.5rem 0; color: #166534; }
        #result p { margin: 0; font-size: 1.5rem; font-weight: bold; color: #3f6212; }
        .spinner { border: 6px solid #f3f3f3; border-top: 6px solid #84cc16; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 20px auto; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Agri<span>Guard</span> 🌱</h1>
            <p>Your AI-powered assistant for healthier crops.</p>
        </div>
        <label for="file-input">
            <div class="upload-area" id="upload-area">
                <p>Click here to upload an image of a plant leaf</p>
            </div>
        </label>
        <input type="file" id="file-input" accept="image/*">
        <div class="spinner" id="spinner"></div>
        <img id="image-preview" src="" alt="Image preview">
        <div id="result">
            <h2>Detected Disease:</h2>
            <p id="result-text"></p>
        </div>
    </div>

    <script>
        const fileInput = document.getElementById('file-input');
        const imagePreview = document.getElementById('image-preview');
        const resultDiv = document.getElementById('result');
        const resultText = document.getElementById('result-text');
        const uploadArea = document.getElementById('upload-area');
        const spinner = document.getElementById('spinner');

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            // Display image preview
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
                imagePreview.style.display = 'block';
            };
            reader.readAsDataURL(file);

            // Hide previous result and show spinner
            resultDiv.style.display = 'none';
            spinner.style.display = 'block';
            uploadArea.style.display = 'none';

            // Create form data and send to API
            const formData = new FormData();
            formData.append('file', file);

            fetch('/predict', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                // Display result
                resultText.textContent = data.disease || 'Could not identify';
                resultDiv.style.display = 'block';
            })
            .catch(error => {
                console.error('Error:', error);
                resultText.textContent = 'An error occurred. Please try again.';
                resultDiv.style.display = 'block';
            })
            .finally(() => {
                // Hide spinner and show upload area again
                spinner.style.display = 'none';
                uploadArea.style.display = 'block';
            });
        });
    </script>
</body>
</html>
"""

# Write the HTML content to a file
with open("index.html", "w") as f:
    f.write(html_content)

print("index.html created successfully.")

from pyngrok import ngrok
import nest_asyncio

nest_asyncio.apply()

ngrok.set_auth_token("1b6j0Ux0LNzp2KsVuvHA0s2D63B_3hZemumYLM1hnD1rK28ny") # Make sure your token is here

# Set up a tunnel to the FastAPI server
public_url = ngrok.connect(8000)
print(f"🚀 AgriGuard is live at: {public_url}")

# Run the FastAPI server
uvicorn.run(app, host="0.0.0.0", port=8000)